{
  "name": "mapper",
  "version": "0.2.4-pre",
  "description": "Lightweight, blazing fast MySQL data mapper.",
  "tags": [
    "odm",
    "mysql",
    "mysql-libmysqlclient"
  ],
  "author": {
    "name": "Mario Gutierrez",
    "email": "mario@mgutz.com"
  },
  "homepage": "https://github.com/mgutz/mapper",
  "dependencies": {
    "async": "~0.1.22",
    "mysql-libmysqlclient": "~1.5.1",
    "lodash": "~1.0.0-rc.3"
  },
  "devDependencies": {
    "mysql": "2.0.0-alpha5",
    "underscore.string": ">= 2.1.1",
    "mocha": "~1.7.4",
    "chai": "~1.4.2",
    "express": "~3.0.6"
  },
  "main": "index",
  "scripts": {
    "test": "make test"
  },
  "engines": {
    "node": ">= 0.6"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/mgutz/mapper/raw/master/LICENSE"
    }
  ],
  "readme": "# Mapper\n\nMapper makes 80% of data access easy and provides unobtrusive access\nto SQL for the 20% complicated, speed-critical tasks.\n\n## Motivation\n\nWanted a lightweight data mapper that is fast and likes SQL.\n\n## Install\n\nTo use mapper in your project\n\n    # For Ubuntu\n    sudo apt-get install libmysqlclient-dev\n\n    npm install mapper\n\nTo run Backbone or AngularJS Example\n\n    git clone git://github.com/mgutz/mapper.git\n    cd mapper\n    npm install -d\n    make test                   # creates necessary database and config.json\n    node example/app.js\n\nthen browse `http://localhost:3000`\n\n## TODO\n\n    Connection pooling - adding SOON\n\n## Quickstart\n\nConect to Database\n\n    var Mapper = require('mapper');\n    var conn = { user: 'grace', password: 'secret', database: 'app_dev' };\n\n    // set verbose flag to trace SQL\n    // set strict to be warned of invalid columns in JSON objects\n    Mapper.connect(conn, {verbose: true, strict: false});\n\nDefine Data Access Objects\n\n    // Table name and optional primary key\n    var Comment = Mapper.map(\"Comments\")\n      , Post = Mapper.map(\"Posts\", \"id\");\n\nDefine Relationships\n\n    Post.hasMany(\"comments\", Comment, \"postId\");\n    Comment.belongsTo(\"post\", Post, \"postId\");\n\nCreate\n\n    var insertId;\n\n    // These are equivalent, where first is more SQL like\n    Post.insert({ title: 'First Post' }).exec(function(err, result) {\n        insertId = result.insertId;\n    });\n    Post.create({ title: 'First Post' }, function(err, result) { ... });\n\nRetrieve\n\n    // Select inserted post\n    Post.where({ id: insertId }).one(function(err, post) {\n        assert.equal(post.title, 'First Post,');\n    });\n\n    Post.findById(insertId, function(err, post) { ... });\n\nUpdate\n\n    // update inserted post\n    Post\n      .update()                         // optional since set() is used\n      .set({ title: 'New Title' })\n      .where({ id: insertId })\n      .exec(function (err, result) {\n        assert.equal(result.affectedRows, 1);\n      });\n\n    // if doc has id set, then save is simple. Note,\n    // pluck only the columns you want updated\n    Post.save(doc, function(err, result) { ... });\n\nDelete\n\n    // delete all posts with a specific title\n    Post.delete().where({ title: 'New Title' }).exec(function(err, result) {\n        assert.equal(result.affectedRows, 1);\n    });\n\n    Post.deleteById(insertId, function(err, result) {});\n\n\nGets the first page of posts and populate comments property with\nthe second page of comments for each post retrieved.\n\n    Post\n      .select('id', 'title', 'excerpt')\n      .page(0, 25)\n      .order('id DESC')\n      .load('comments', function(c) {\n        c.select('comment', 'createdAt')\n         .order('id DESC')\n         .page(1, 50);\n      })\n      .all(function(err, posts) {\n        // boo-yah!\n      });\n\nOR, if you prefer SQL\n\n    var sql = (\"SELECT id, title, excerpt FROM `Posts` \\\n                ORDER BY id DESC LIMIT 0, 25\";\n\n    Post.all(sql, function(err, posts) {\n      Post.load('comments', function(c) {\n        c.sql(\"SELECT comment, createdAt FROM Comments ORDER BY id DESC LIMIT 1, 50\");\n      }).in(posts, function(err) {\n        // boo-yah!\n      });\n    });\n\n\n## SQL goodness\n\nExecuting multiple statements in a series\n\n    Mapper.client.execSeries(\n      \"SELECT * FROM posts WHERE author = ?\", [1],\n\n      // SQL may be separated by `,`\n      \"SELECT * \",\n      \"FROM comments WHERE author = ?\", [1],\n\n      function(err, results) {\n        // posts are in results[0][0..n]\n        // comments are in results[1][0..n]\n      }\n    );\n\n\nExecuting multiple statements in parallel\n\n    Mapper.client.execParallel(\n      \"SELECT * FROM posts WHERE author = ?\", [1],\n      \"SELECT * FROM comments WHERE author = ?\", [1],\n      function(err, results) {\n      }\n    );\n\n## Benchmarks\n\nTime for 100,000 iterations alternating between insert and select. See `test/bench`\nor run `make bench`.\n\n    time node test/bench/testMysql.js (mysql 2.0.0-alpha3)\n\n    real        1m27.239s\n    user        0m58.506s\n    sys         0m3.288s\n\n    time node test/bench/testMapperDao.js\n\n    real        0m30.701s\n    user        0m11.346s\n    sys         0m4.403s\n\n    time node test/bench/testLibMysql.js\n\n    real        0m26.044s\n    user        0m8.207s\n    sys         0m3.784s\n\n    time node test/bench/testMongo.js (just for fun)\n\n    real        0m41.771s\n    user        0m30.830s\n    sys         0m2.910s\n\nThe takeaway is `mysql-libmysqlclient` is a much faster driver than the\nwidely used `mysql` driver. Mapper, which is based on `mysql-libmysqlclient` adds\noverhead yet outperforms the raw `mysql` driver.\n\nEven more surprising is Mapper is faster than MongoDB using the official MongoDB\ndriver for node.js.\n\n## Implementation Best Practice\n\nA simple approach, without over-engineering your project, is to maintain\n3 distinct layers in your code:\n\n1. Data Access Objects (DAO) - Responsible for interacting with the database.\n   There should be 1 DAO for each table used by project.\n2. Models - A model uses one or more DAO adding business logic, validations as needed.\n3. Resources or Services - This layer should only use models never DAO.\n\nOn a more complex project where a few tables might be better stored in Redis for\nexample, insert a Repository layer between DAO and models to insulate models\ncompletely from low-level data access.\n",
  "readmeFilename": "README.md",
  "_id": "mapper@0.2.4-pre",
  "dist": {
    "shasum": "25de92fb8065d5c9be449f08b5e1adff6f2102f3"
  },
  "_from": "mapper@",
  "_resolved": "https://registry.npmjs.org/mapper/-/mapper-0.2.4-pre.tgz"
}
